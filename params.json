{"name":"Josh.github.io","tagline":"","body":"###Rvalue semantics in C++11\r\n\r\nHave you wanted to just move variables from one place to another? Intuitively, it makes sense to simply move data from one location to another. Most of the time what programmers tend to do is make a copy of the object they are passing and then simply destroy the original, but what if that particular object is massive in size and costly to store in memory? This is where rvalue semantics in C++11 come in handy!\r\nLets take a look at some types: \r\n```\r\nint a {10};  //OK standard lvalue type\r\nint* b {&a}; //OK standard pointer type, initialised to point to a\r\nint& c {a}  //OK standard reference type, initialised to reference a\r\nint&& d {square(a)} //OK standard rvalue type, initialised to the return of sqrt(a)\r\n//but what does this mean?\r\n```\r\n\r\nThe standard syntax of rvalue types is: `T&&` with `&&` meaning rvalue reference. To the compiler when you make a variable with this type it can only bind to temporary variables. Let's see some examples:\r\n```\r\nint a {10};\r\nint& b {a};\r\nstd::string helloMessage(); //function that returns a std::string object\r\nint&& var1 {a}; //error: a is not an rvalue or temporary, is an lvalue\r\nint&& var2 {square(a)}; //OK: sqrt() returns a temporary of type int\r\nint&& var3 {10}; //OK: 10 is a temporary variable, var3 can bind to it\r\nint&& var4 {b};         //error: b is a lvalue reference\r\nstd::string&& var5 {\"Hello, World!\\n\"}; //OK: var5 constructs a string object and binds to the temporary\r\nstd::string&& var6 {helloMessage()};    //OK: helloMessage() returns a temporary string object\r\n\r\n```\r\nOne thing to note about rvalue references, however, is that an rvalue reference are treated like a lvalue. Why? Like any reference, an rvalue reference is just another name for an object. We cannot bind an lvalue to a function or expression that requires an rvalue reference.\r\nSo now that we understand a little bit of syntax, and maybe some semantics, how can we use it in our code to make it more efficient? Perhaps the most common use of move semantics is in moving containers around. Let's take a look:\r\n```\r\ntemplate <typename T>\r\nclass array {\r\n  std::unique_ptr<T[]> elem;\r\n  int m_size;\r\n public:\r\n  array(int size): elem{new int[size] { }}, m_size{size} { }\r\n  array()=delete;\r\n  const T* begin() const noexcept {return elem.get();}\r\n  const T* end() const noexcept {return elem.get()+m_size;}\r\n  constexpr int size() const {return m_size;}\r\n  T& operator[](int n) {return elem[n];}\r\n  const T& operator[](int n) const {return elem[n];}\r\n};\r\n```\r\nThis is a very simplified version of a container. Now, traditionally, we would define an operator `=' in order to copy this container to another variable, maybe we need to modify one and keep the original, but what if we only need one copy and a function returned the result as our array class? Assume that we have an operator = defined like this: \r\n```\r\ntemplate <typename T>\r\narray<T>& array<T>::operator=(const array<T>& arr) {\r\n  elem.reset(new int[arr.size()] { });\r\n  for (int i {};i != arr.size();++i)\r\n    elem[i] = arr[i];\r\n  return *this;\r\n}\r\n```\r\nWe might also define a copy constructor similarly. This is fine if we have to lvalue objects, but it's absolutely awful if we have a temporary! Why? Well we make a copy of the already temporary object we bind our const reference to, for example:\r\n```\r\narray<int> arr{5};\r\narr = make_array_of_7s(5); //a function that returns a new array object of size 5 full of 7's\r\n```\r\nAs you can see, this is a small problem because first we construct the array object in the function, then we construct a new pointer in the `=' operator while deleting the old one, THEN we go through each element of of the temporary object and assign it. Oh did I mention that the temporary object gets deleted on top of that?! That is some overhead... Luckily, C++11 solves this overhead. Now we can define a simple `=' operator simply for moving objects:\r\n```\r\ntemplate <typename T>\r\narray<T>& array<T>::operator=(array<T>&& arr) {\r\n  elem   = arr.elem;\r\n  m_size = arr.size();\r\n  return *this;\r\n}\r\n```\r\nMuch better! As you can see, this is a much friendlier operation. There is only one call to delete this time and there is no need for a new operator! This is the philosophy behind moving objects. A move-constructor might be defined very similarly for our array object.\r\n\r\n## Rvalue references and functions + templates\r\nRvalues can be used virtually everywhere you can have an argument, and functions are no different. If we wanted to make a \"perfect\" swap function we might do something like this:\r\n```\r\ntemplate <typename T>\r\nvoid swap(T& a, T& b) {\r\n  T tmp {std::move(a)}; //a may or may not be valid data\r\n  a = std::move(b);     //b may or may not be valid data\r\n  b = std::move(tmp);\r\n}\r\n```\r\nThe std::move function will basically statically cast it's argument to be a type T&& and any move constructors or move based assignments will pick this cast up and perform the move operation.\r\n\r\n### Advanced rvalue references\r\nWe can declare functions that only take rvalues if we wanted to, but more importantly is that rvalues solve a very important problem we previously had with function templates, and that is the perfect forwarding problem. Let's take a look at what the problem is (you may find this example in the ISO specification document):\r\n```\r\ntemplate <typename T, typename Arg>\r\nstd::shared_ptr<T> factory(Arg& arg) {\r\n  return std::shared_ptr<T>{new T{arg}};\r\n}\r\n```\r\nNow this might look solid to that naked eye but there is a pretty big problem here, we can't call this function with rvalues. Why? Well because the argument of type Arg is a reference and a reference cannot bind to an rvalue:\r\n```\r\nint a {10};\r\nfactory<int>(a);  //OK: a can bind to a reference\r\nfactory<int>(square(a)); //error if square returns by value\r\nfactory<int>(10);  //error: cannot bind arg of type int& to a temporary\r\n```\r\nA pre-C++11 approach might be to define the function as follows:\r\n```\r\ntemplate <typename T, typename Arg>\r\nstd::shared_ptr<T> factory(const Arg& arg) { //Notice the const\r\n    return std::shared_ptr<T>{new T{arg}};\r\n}\r\n```\r\nNow we can call this function with rvalues, but this solution presents two problems of it's own. Firstly we block out move semantics because now all of our rvalues would get forwarded to this overload and it's impossible to tell if it was an rvalue or lvalue. Secondly it scales poorly because if we have a similar function with more arguments we have to define const and non-const versions of the same function. C++11 to the rescue! As it provides us with a perfect way to fix this issue using rvalue references, but firstly we need to understand some reference collapsing rules in C++11:\r\n```\r\nT&  &  -> T&\r\nT&  && -> T&\r\nT&& &  -> T&\r\nT&& && -> T&&\r\n```\r\nSo, in other words, T& always wins if given two different reference types. While this may seem confusing it will make more sense if we look at the function template defined as follows:\r\n```\r\ntemplate <typename T, typename Arg>\r\nstd::shared_ptr<T> factory(Arg&& arg) { //Notice the argument is now a &&\r\n  return std::shared_ptr<T>{new T{std::forward<Arg>(arg)}};\r\n}\r\n```\r\nThe significance of std::forward will be explained later. So what happens when we call it with an lvalue:\r\n```\r\nint a {10};\r\nfactory<int>(a);\r\n```\r\nThe compiler will instantiate the template like so:\r\n```\r\nstd::shared_ptr<int> factory(int& && arg) {\r\n  return std::shared_ptr<int>{new int{std::forward<int&>(arg)}};\r\n}\r\n```\r\nRemember those reference collapsing rules? That funny looking int& && simply becomes int& which is correct given the type. So now let us call it with an rvalue:\r\n```\r\nfactory<int>(10);\r\n```\r\nThe compiler will instantiate the template like so:\r\n```\r\nstd::shared_ptr<int> factory(int&& && arg) {\r\n  return std::shared_ptr<int>{new int{std::forward<int&&>(arg)}};\r\n}\r\n```\r\nAgain the reference collapsing rules take over and int&& && becomes int&& which, again, what we want. The purpose of std::forward is to preserve move semantics and since we gave our argument a name `arg' then it will always call the copy constructor of our type T when we call it with arg and not the move constructor.\r\n### Restricted Class(A very vague example)\r\nLet's say, Foo is a restricted class with the following definition:\r\n```\r\ntemplate < class T, class U >\r\nstruct Foo\r\n{\r\n    Foo() = delete;\r\n    Foo(T && _1, U && _2): foo_1(_1), foo_2( _2) {}\r\n    ...\r\n    ~Foo() {}\r\n    T foo_1;\r\n    U foo_2;\r\n};\r\n\r\ntemplate<typename _Tp, typename _Tp2>\r\nFoo <_Tp, _Tp2> produce_foo(_Tp &&x, _Tp2 &&y)\r\n{\r\n return Foo<_Tp, _Tp2> { {std::forward<_Tp> (x)}, {std::forward<_Tp2>(y) } };\r\n}\r\n```\r\nThis class, for weird reasons, defines only a move constructor, therefore forbids binding an lvalue object to its ctors. Every instantiation of Foo objects requires a movable object. The function, produce_foo, is a \"foo factory producer\" that strictly requires an rvalue.\r\n```\r\nFoo<std::string, double> && material = produce_foo<std::string, double>(\"Cotton\", 12.4f); //OK, rvalue reference\r\n//if store is a vector of type Foo<std::string, double>, then\r\nstore.emplace_back(material); //would be an error! material is an lvalue\r\n\r\nstore.emplace_back(std::move(material)); //would be OK, material is an rvalue\r\n```\r\nAs a bottom line, USE MOVES. They are efficient ways of dealing with large amounts of data and can make you even write less code (perfect forwarding!). So get your std::move on!\r\n\r\nOriginally written by Cameron DaCamara, edited and recompiled by Ogunyinka Josh.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}